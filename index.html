<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>A-Frame Raytrace Component - Basic</title>
    <meta name="description" content="Basic example for Raytrace component."></meta>
    <script src="https://aframe.io/releases/1.0.3/aframe.min.js"></script>
    <script src="aframe-raytrace-component.js"></script>
  </head>
  <body>

    <script id="fs" type="x-shader/x-fragment">
       precision mediump float;
      
      uniform float time;
      uniform vec3 localCameraPos;
      varying vec3 localSurfacePos;


      // Created by David Gallardo - xjorma/2020
      // License Creative Commons Attribution-NonCommercial-ShareAlike 3.0


      const float layerThickness  = 0.02;
      const int nbLayers    = 3;


      float sdTorus( vec3 p, vec2 t )
      {
          return length( vec2(length(p.xz)-t.x,p.y) )-t.y;
      }


      float mySaturate(float c)
      {
          return clamp(c,0.,1.);
      }


      vec2 minVecSelect(vec2 a, vec2 b)
      {
          return a.x<b.x?a:b;
      }

      float hash( float n )
      {
          return fract(sin(n)*43758.5453);
      }

      float noise( in vec3 x )
      {
          vec3 p = floor(x);
          vec3 f = fract(x);

          f = f*f*(3.0-2.0*f);

          float n = p.x + p.y*57.0 + 113.0*p.z;

          float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),
                              mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),
                          mix(mix( hash(n+113.0), hash(n+114.0),f.x),
                              mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);
          return res;
      }

      vec2 map(in vec3 p)
      {
          float slide = time / 1000.;
          float fr = fract(slide);
          int   fl = int(floor(slide));    
          vec2  vd = vec2(100., -1.);
          float cnoise = noise(p * 2. + time / 8000.) / 3.;
          for( int i = 0; i < nbLayers; i++)
          {
              float m = mod(float(i + fl), float(nbLayers));
              float r = 0.6 - m * layerThickness + ( 1. - fr) * layerThickness;
              float d = sdTorus( p, vec2(1, r)) ;
              d = abs(d) - layerThickness / 2.;
              float o =  - 4. * fract( (time/1000. + float(i)) / float(nbLayers));
          d = max(d, 1.5 + p.x  + o + cnoise);
          vd = minVecSelect(vec2(d, float(i)), vd);        
          }   
          return vd;
      }


      vec3 calcNormal(vec3 p)
      {
          const float h = 0.001;
          const vec2 k = vec2(1,-1);
          return normalize( k.xyy * map(p + k.xyy*h).x + 
                            k.yyx * map(p + k.yyx*h).x + 
                            k.yxy * map(p + k.yxy*h).x + 
                            k.xxx * map(p + k.xxx*h).x );
      }

      // From IQ
      float calcAO( in vec3 pos, in vec3 nor )
      {
        float occ = 0.0;
          float sca = 1.0;
          for( int i=0; i<5; i++ )
          {
              float hr = 0.01 + 0.12*float(i)/12.0;
              vec3 aopos =  nor * hr + pos;
              float dd = map( aopos ).x;
              occ += -(dd-hr)*sca;
              sca *= 0.95;
          }
          return mySaturate(1.0 - 4. * occ);    
      }


      vec3 Render(vec3 ro,vec3 rd,vec3 cd,float dist)
      {
          float t = 0.5;
          float d;
          float m = 0.;
          for( int i=0; i<1024; i++ )
          {
              vec3  p = ro + t*rd;
              vec2  h = map(p);
              t += h.x*0.7;
              d = dot(t*rd,cd);
              m = h.y;
              if( abs(h.x)<0.0001 || d>dist ) break;
          }

          vec3 col = vec3(0.3);

          if( d<dist )
          {
              vec3 light = vec3(0.,4.,2.);
              vec3 p = ro + t*rd;
              vec3 n = calcNormal(p);
              vec3 v = normalize(ro-p);
              vec3 l = normalize(light-p);
              vec3 h = normalize(l+v);
              
              vec3 diffcol = normalize(vec3(1. + sin(m * 0.7 + 1.3) / 2., 1. + sin(m * 1.3 + 4.45) / 2., 1. + sin(m * 1.9 + 2.3) / 2.)); 
              vec3 speccol = vec3(1.,1.,1.);
              vec3 ambcol = diffcol;
              float ao = calcAO(p, n);
              
              col = mySaturate(dot(n,l)) * diffcol;
              col+= pow(mySaturate(dot(n,h)),40.) * speccol * 0.5;
              col+= 0.2 * ambcol;
              col*= ao;
          }
          return col;
      }

      void mainVR( out vec4 fragColor, in vec3 ro, in vec3 rd )
      {
          fragColor = vec4(Render(ro/3. + vec3(0.0,1.0,2.5),rd ,rd,14.) ,1);
      }

     void main(){
        
        vec3 rayPos = localSurfacePos;
        vec3 rayDir = normalize(localSurfacePos-localCameraPos);
        vec4 color = vec4(0.0);
        mainVR(color, rayPos, rayDir);
        gl_FragColor = color;
        
      }
      
    </script>

    <a-scene stats background="color: black;">
      <a-entity position="0 0 0">
        <a-box position="0 1.65 0" scale="0.25 0.25 0.25" raytrace="shader:#fs; backside:true;"></a-box>
      </a-entity>
      
    </a-scene>
  </body>
</html>
